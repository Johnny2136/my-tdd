"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.startWebDriver = startWebDriver;
exports.stopWebDriver = stopWebDriver;
exports.createSession = createSession;
exports.closeSession = closeSession;
exports.runQueue = runQueue;

var _nightwatch = require("nightwatch");

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _logger = require("./logger");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let runner;
let client;

function createRunner(env = 'default') {
  if (!runner) {
    const jsonConfigFile = './nightwatch.json';

    const jsConfigFie = _path.default.resolve('./nightwatch.conf.js');

    const configFile = _fs.default.existsSync(jsConfigFie) ? jsConfigFie : jsonConfigFile;
    runner = (0, _nightwatch.CliRunner)({
      env,
      config: configFile
    });

    runner.isWebDriverManaged = function () {
      if (this.baseSettings.selenium) {
        this.baseSettings.selenium.start_process = true;
      }

      return true;
    };

    runner.setup();
  }

  return runner;
}

async function startWebDriver(env) {
  createRunner(env);
  await runner.startWebDriver();
  (0, _logger.log)(`WebDriver started on port ${runner.test_settings.webdriver.port}`);
}

async function stopWebDriver() {
  await runner.stopWebDriver();
  (0, _logger.log)(`WebDriver stopped on port ${runner.test_settings.webdriver.port}`);
}

async function createSession(env) {
  createRunner(env);
  const settings = runner.test_settings;
  client = (0, _nightwatch.client)(settings);
  await client.startSession();
  (0, _logger.log)('Session created');
  return client.api;
}

async function closeSession() {
  client.queue.empty();
  client.queue.reset();
  client.session.close();
  await runQueue();
  (0, _logger.log)('Session closed');
}

async function runQueue() {
  try {
    await new Promise((resolve, reject) => {
      client.queue.run(err => {
        if (!err || !(err.abortOnFailure || err.abortOnFailure === undefined)) {
          resolve();
          return;
        }

        err.stack = [err.message, err.stack].join('\n');
        reject(err);
      });
    });
  } catch (err) {
    throw err;
  } finally {
    client.queue.removeAllListeners();
    client.queue.empty();
    client.queue.reset();
  }
}